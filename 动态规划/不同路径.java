//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
//
// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
//
// 问总共有多少条不同的路径？
//
//
//
// 示例 1：
//
//
//输入：m = 3, n = 7
//输出：28
//
// 示例 2：
//
//
//输入：m = 3, n = 2
//输出：3
//解释：
//从左上角开始，总共有 3 条路径可以到达右下角。
//1. 向右 -> 向右 -> 向下
//2. 向右 -> 向下 -> 向右
//3. 向下 -> 向右 -> 向右
//
//
// 示例 3：
//
//
//输入：m = 7, n = 3
//输出：28
//
//
// 示例 4：
//
//
//输入：m = 3, n = 3
//输出：6
//
//
//
// 提示：
//
//
// 1 <= m, n <= 100
// 题目数据保证答案小于等于 2 * 109
//
// Related Topics 数组 动态规划
// 👍 849 👎 0


//leetcode submit region begin(Prohibit modification and deletion)
class 不同路径 {

//  1，动态规划解决
//
//  注意这里机器人只能向下和向右移动，不能往其他方向移动，我们用dp[i][j]表示到坐标(i，j)这个格内有多少条不同的路径，所以最终的答案就是求dp[m-1][n-1]。
//
//  因为只能从上面或左边走过来，所以递推公式是
//
//  dp[i][j]=dp[i-1][j]+dp[i][j-1]。
//  dp[i-1][j] 表示的是从上面走过来的路径条数。
//  dp[i][j-1] 表示的是从左边走过来的路径条数。
//  那么边界条件是什么呢，如果Finish在第一行的任何位置都只有一条路径，同理Finish在第一列的任何位置也都只有一条路径，所以边界条件是第一行和第一列都是1。我们已经找到了递推公式，又找到了边界条件，所以动态规划代码很容易写出来，我们来看下

  public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int i = 0; i < n; i++) dp[0][i] = 1;

    for (int i = 1; i < m; i++) {
      for (int j = 1; j < n; j++) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
      }

    }
    return dp[m - 1][n - 1];
  }
}
//leetcode submit region end(Prohibit modification and deletion)

